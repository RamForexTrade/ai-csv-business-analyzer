"""\nEnhanced Web Scraping Module with Real-time Progress Updates and Email Integration\nRailway-compatible version with aggressive UI refreshing and Editable Results\n"""\n\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport os\nimport sys\nimport asyncio\nimport importlib\nimport dotenv\nfrom dotenv import load_dotenv\nimport time\nimport concurrent.futures\nimport threading\n\ndef get_env_var(key, default=None):\n    \"\"\"Get environment variable from Railway environment or .env file\"\"\"\n    # First try regular environment variables (Railway uses these)\n    value = os.getenv(key)\n    if value:\n        return value\n\n    # Then try Streamlit secrets (for Streamlit Cloud deployment)\n    try:\n        if hasattr(st, 'secrets') and key in st.secrets:\n            return st.secrets[key]\n    except Exception:\n        pass\n\n    # Finally try .env file (local development)\n    try:\n        load_dotenv()\n        return os.getenv(key, default)\n    except Exception:\n        return default\n\nclass ProgressTracker:\n    \"\"\"Real-time progress tracking with aggressive UI updates\"\"\"\n    \n    def __init__(self, total_businesses):\n        self.total_businesses = total_businesses\n        self.current_business = 0\n        self.current_stage = \"\"\n        self.business_name = \"\"\n        self.start_time = time.time()\n        \n        # Create UI elements\n        self.main_progress = st.progress(0)\n        self.status_container = st.empty()\n        self.business_container = st.empty()\n        self.details_container = st.empty()\n        self.results_container = st.empty()\n        self.debug_container = st.empty()\n        \n        # Results tracking\n        self.successful = 0\n        self.manual_required = 0\n        self.government_verified = 0\n        self.last_update = time.time()\n        \n    def force_refresh(self):\n        \"\"\"Force Streamlit to refresh the UI\"\"\"\n        try:\n            # Multiple methods to force UI refresh\n            time.sleep(0.05)  # Small delay to allow render\n            \n            # Update timestamp to show it's alive\n            elapsed = time.time() - self.start_time\n            self.debug_container.caption(f\"‚è±Ô∏è Running: {elapsed:.1f}s | Last update: {time.strftime('%H:%M:%S')}\")\n            \n        except Exception as e:\n            # Ignore refresh errors\n            pass\n        \n    def update_business(self, business_num, business_name):\n        \"\"\"Update current business being processed\"\"\"\n        self.current_business = business_num\n        self.business_name = business_name\n        self.last_update = time.time()\n        \n        progress = (business_num - 1) / self.total_businesses\n        self.main_progress.progress(progress)\n        \n        self.business_container.info(f\"üè¢ **Business {business_num}/{self.total_businesses}:** {business_name}\")\n        \n        self.force_refresh()\n        \n    def update_stage(self, stage, details=\"\"):\n        \"\"\"Update current processing stage\"\"\"\n        self.current_stage = stage\n        self.last_update = time.time()\n        \n        stage_icons = {\n            \"initializing\": \"üöÄ\",\n            \"api_test\": \"üß™\",\n            \"preparing\": \"üìã\",\n            \"general_search\": \"üìä\", \n            \"government_search\": \"üèõÔ∏è\",\n            \"industry_search\": \"üå≤\",\n            \"extracting\": \"ü¶ô\",\n            \"verifying\": \"üîç\",\n            \"completed\": \"‚úÖ\",\n            \"failed\": \"‚ùå\",\n            \"timeout\": \"‚è∞\"\n        }\n        \n        icon = stage_icons.get(stage, \"‚öôÔ∏è\")\n        self.status_container.info(f\"{icon} **{stage.replace('_', ' ').title()}** {details}\")\n        \n        self.force_refresh()\n        \n    def update_details(self, details):\n        \"\"\"Update detailed progress information\"\"\"\n        self.last_update = time.time()\n        self.details_container.write(f\"üìù {details}\")\n        self.force_refresh()\n        \n    def add_result(self, status, government_sources=0):\n        \"\"\"Track research results\"\"\"\n        if status == \"success\":\n            self.successful += 1\n            if government_sources > 0:\n                self.government_verified += 1\n        elif status == \"manual_required\":\n            self.manual_required += 1\n            \n        # Update results summary\n        self.results_container.write(f\"\"\"\n        **üìä Progress Summary:**\n        - ‚úÖ Successful: {self.successful}\n        - üèõÔ∏è Government Verified: {self.government_verified}  \n        - üîç Manual Required: {self.manual_required}\n        \"\"\")\n        \n        self.force_refresh()\n        \n    def complete(self):\n        \"\"\"Mark research as completed\"\"\"\n        self.main_progress.progress(1.0)\n        self.status_container.success(\"üéâ **Research Completed Successfully!**\")\n        \n        total_time = time.time() - self.start_time\n        self.debug_container.success(f\"‚úÖ Completed in {total_time:.1f} seconds\")\n\ndef create_editable_results_interface():\n    \"\"\"Create an editable interface for research results\n    \n    Fixed Issue: Table not saving changes on first save in edit mode.\n    \n    Solution: \n    - Properly initialize data editor session state before first use\n    - Store current editor state after each interaction\n    - Ensure latest data is captured from editor state during save\n    - Clear and refresh editor state on mode changes and resets\n    \"\"\"\n    \n    if not st.session_state.get('research_completed', False):\n        return\n\n    if not st.session_state.get('research_results') is not None:\n        return\n        \n    # Show success message if changes were saved recently\n    if st.session_state.get('changes_saved', False):\n        st.success(\"‚úÖ Your changes have been saved successfully and applied!\")\n        # Clear the success flag after displaying\n        del st.session_state['changes_saved']\n        \n    # Handle post-save state\n    if st.session_state.get('just_saved', False):\n        st.info(\"üéâ Save completed! You are now viewing the updated results.\")\n        # Clear the just_saved flag\n        del st.session_state['just_saved']\n        \n    # Handle reset state\n    if st.session_state.get('reset_clicked', False):\n        st.info(\"üîÑ Edit mode reset - back to read-only view.\")\n        # Clear the reset flag\n        del st.session_state['reset_clicked']\n        \n    st.markdown(\"---\")\n    st.subheader(\"‚úèÔ∏è **Edit Research Results**\")\n    \n    # Toggle between view and edit mode\n    col_toggle1, col_toggle2 = st.columns([1, 3])\n    \n    with col_toggle1:\n        edit_mode = st.toggle(\n            \"üìù Edit Mode\", \n            value=st.session_state.get('results_edit_mode', False),\n            help=\"Toggle to enable editing of research results\"\n        )\n        \n        # If entering edit mode for the first time, clear any existing editor state\n        # This ensures a fresh start for the data editor\n        if edit_mode and not st.session_state.get('results_edit_mode', False):\n            editor_key = \"business_data_editor\"\n            if editor_key in st.session_state:\n                del st.session_state[editor_key]\n            if f\"{editor_key}_current\" in st.session_state:\n                del st.session_state[f\"{editor_key}_current\"]\n        \n        st.session_state.results_edit_mode = edit_mode\n    \n    with col_toggle2:\n        if edit_mode:\n            st.info(\"‚úèÔ∏è Edit mode enabled - you can modify the research results below\")\n        else:\n            st.info(\"üëÄ View mode - research results are read-only\")\n    \n    # Get current results\n    results_df = st.session_state.research_results.copy()\n    \n    # Initialize email selection state if not exists\n    if 'selected_for_email' not in st.session_state:\n        # Default: select businesses that have email addresses\n        has_email = (results_df['email'].notna() & \n                    (results_df['email'] != '') & \n                    (results_df['email'] != 'Not found') &\n                    (results_df['email'] != 'Research required') &\n                    (~results_df['email'].str.contains('not relevant', case=False, na=False)))\n        st.session_state.selected_for_email = has_email.tolist()\n    \n    # Ensure selection list matches current dataframe length\n    if len(st.session_state.selected_for_email) != len(results_df):\n        # Resize selection list to match dataframe\n        current_length = len(st.session_state.selected_for_email)\n        df_length = len(results_df)\n        \n        if df_length > current_length:\n            # Extend with False for new rows\n            st.session_state.selected_for_email.extend([False] * (df_length - current_length))\n        else:\n            # Truncate if dataframe is smaller\n            st.session_state.selected_for_email = st.session_state.selected_for_email[:df_length]\n    \n    if edit_mode:\n        # Email Selection Controls\n        st.markdown(\"### üìß **Email Selection Controls**\")\n        \n        # Count selected businesses and those with emails\n        total_selected = sum(st.session_state.selected_for_email)\n        businesses_with_emails = sum([\n            selected and \n            pd.notna(results_df.iloc[i]['email']) and \n            results_df.iloc[i]['email'] not in ['', 'Not found', 'Research required'] and\n            'not relevant' not in str(results_df.iloc[i]['email']).lower()\n            for i, selected in enumerate(st.session_state.selected_for_email)\n        ])\n        \n        # Selection summary and controls\n        col_sel1, col_sel2, col_sel3, col_sel4 = st.columns(4)\n        \n        with col_sel1:\n            st.metric(\"üìß Selected for Email\", total_selected)\n        \n        with col_sel2:\n            st.metric(\"‚úÖ With Valid Emails\", businesses_with_emails)\n        \n        with col_sel3:\n            if st.button(\"‚òëÔ∏è Select All\", key=\"select_all_email\"):\n                st.session_state.selected_for_email = [True] * len(results_df)\n                st.rerun()\n        \n        with col_sel4:\n            if st.button(\"‚òê Clear All\", key=\"clear_all_email\"):\n                st.session_state.selected_for_email = [False] * len(results_df)\n                st.rerun()\n        \n        # Quick selection buttons\n        col_quick1, col_quick2 = st.columns(2)\n        \n        with col_quick1:\n            if st.button(\"üìß Select Only With Emails\", key=\"select_with_emails\"):\n                st.session_state.selected_for_email = [\n                    pd.notna(row['email']) and \n                    row['email'] not in ['', 'Not found', 'Research required'] and\n                    'not relevant' not in str(row['email']).lower()\n                    for _, row in results_df.iterrows()\n                ]\n                st.rerun()\n        \n        with col_quick2:\n            if st.button(\"üèõÔ∏è Select Gov Verified\", key=\"select_gov_verified\"):\n                st.session_state.selected_for_email = [\n                    row.get('government_verified', 'NO') == 'YES'\n                    for _, row in results_df.iterrows()\n                ]\n                st.rerun()\n        \n        st.markdown(\"### üìù **Editable Results Table**\")\n        st.markdown(\"üí° **Instructions:** Click on any cell to edit. Use checkboxes to select businesses for email campaigns.\")\n        \n        # Create editable interface\n        edited_results = create_editable_business_data(results_df)\n        \n        # Save changes button\n        col_save1, col_save2, col_save3 = st.columns([2, 1, 1])\n        \n        with col_save1:\n            save_clicked = st.button(\"üíæ Save Changes\", type=\"primary\", key=\"save_changes_btn\")\n            \n            if save_clicked:\n                # Ensure we have the latest edited data from the data editor\n                editor_key = \"business_data_editor\"\n                \n                # Get the most recent data from the editor state\n                if f\"{editor_key}_current\" in st.session_state:\n                    latest_edited_data = st.session_state[f\"{editor_key}_current\"]\n                    # Remove send_email column if present\n                    if 'send_email' in latest_edited_data.columns:\n                        edited_results = latest_edited_data.drop(columns=['send_email'], errors='ignore')\n                    else:\n                        edited_results = latest_edited_data\n                else:\n                    # Fallback to the returned edited_results\n                    edited_results = edited_results\n                \n                # Validate that we have data to save\n                if edited_results is None or edited_results.empty:\n                    st.error(\"‚ùå No data to save. Please make sure you have edited the table.\")\n                else:\n                    # Update the session state with edited results\n                    st.session_state.research_results = edited_results.copy()\n                    \n                    # Update the researcher instance results if available\n                    if 'researcher_instance' in st.session_state:\n                        researcher = st.session_state.researcher_instance\n                        # Update the internal results of the researcher\n                        update_researcher_results(researcher, edited_results)\n                    \n                    # Set flags for post-save state\n                    st.session_state.changes_saved = True\n                    st.session_state.results_edit_mode = False\n                    st.session_state.just_saved = True\n                    \n                    # Clear any existing editor state to force a refresh\n                    if editor_key in st.session_state:\n                        del st.session_state[editor_key]\n                    if f\"{editor_key}_current\" in st.session_state:\n                        del st.session_state[f\"{editor_key}_current\"]\n                    \n                    # Show immediate success message\n                    st.success(\"‚úÖ Changes saved successfully!\")\n                    st.balloons()\n                    \n                    # Let the user know the changes are saved and they should refresh manually if needed\n                    st.info(\"üîÑ Changes saved! The interface will update shortly.\")\n                    \n                    # Use a lighter refresh approach\n                    time.sleep(1.5)\n                    st.rerun()\n        \n        with col_save2:\n            reset_clicked = st.button(\"üîÑ Reset\", key=\"reset_changes_btn\")\n            if reset_clicked:\n                # Clear editor state to reset to original data\n                editor_key = \"business_data_editor\"\n                if editor_key in st.session_state:\n                    del st.session_state[editor_key]\n                if f\"{editor_key}_current\" in st.session_state:\n                    del st.session_state[f\"{editor_key}_current\"]\n                \n                st.session_state.results_edit_mode = False\n                st.session_state.reset_clicked = True\n                st.info(\"üîÑ Reset completed - returning to view mode.\")\n                time.sleep(1)\n                st.rerun()\n                \n        with col_save3:\n            # Download edited results\n            csv_data = edited_results.to_csv(index=False)\n            st.download_button(\n                label=\"üì• Download\",\n                data=csv_data,\n                file_name=f\"edited_research_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                mime=\"text/csv\"\n            )\n        \n        # Show changes summary\n        if not edited_results.equals(results_df):\n            st.markdown(\"### üìä **Changes Summary**\")\n            changes_detected = show_changes_summary(results_df, edited_results)\n            if changes_detected:\n                st.info(f\"üìù {changes_detected} changes detected. Click 'Save Changes' to apply them.\")\n    \n    else:\n        # View mode - show results in read-only format  \n        st.markdown(\"### üëÄ **Research Results (Read-Only)**\")\n        \n        # Show email selection summary in view mode\n        if 'selected_for_email' in st.session_state:\n            total_selected = sum(st.session_state.selected_for_email)\n            businesses_with_emails = sum([\n                selected and \n                pd.notna(results_df.iloc[i]['email']) and \n                results_df.iloc[i]['email'] not in ['', 'Not found', 'Research required'] and\n                'not relevant' not in str(results_df.iloc[i]['email']).lower()\n                for i, selected in enumerate(st.session_state.selected_for_email) if i < len(results_df)\n            ])\n            \n            # Quick selection controls in view mode\n            col_view1, col_view2, col_view3, col_view4 = st.columns(4)\n            \n            with col_view1:\n                st.metric(\"üìß Selected\", total_selected)\n            \n            with col_view2:\n                st.metric(\"‚úÖ With Emails\", businesses_with_emails)\n            \n            with col_view3:\n                if st.button(\"üìß Quick: Select All with Emails\", key=\"quick_select_emails_view\"):\n                    st.session_state.selected_for_email = [\n                        pd.notna(row['email']) and \n                        row['email'] not in ['', 'Not found', 'Research required'] and\n                        'not relevant' not in str(row['email']).lower()\n                        for _, row in results_df.iterrows()\n                    ]\n                    st.rerun()\n            \n            with col_view4:\n                if st.button(\"‚òê Quick: Clear All\", key=\"quick_clear_all_view\"):\n                    st.session_state.selected_for_email = [False] * len(results_df)\n                    st.rerun()\n            \n            if total_selected > 0:\n                st.success(f\"üëç **Ready for Email Campaign:** {businesses_with_emails} businesses with emails selected (out of {total_selected} total)\")\n            else:\n                st.info(\"üí° **Tip:** Use 'Quick: Select All with Emails' above or Edit Mode to select businesses for email campaigns.\")\n        \n        else:\n            st.info(\"üìß **Email Selection:** No selection data available. Complete business research first.\")\n            # Show basic metrics without selection functionality\n            total_with_emails = sum([\n                pd.notna(row['email']) and \n                row['email'] not in ['', 'Not found', 'Research required'] and\n                'not relevant' not in str(row['email']).lower()\n                for _, row in results_df.iterrows()\n            ])\n            \n            if total_with_emails > 0:\n                st.info(f\"üìß **Available for Email:** {total_with_emails} businesses have email addresses\")\n                if st.button(\"üîÑ Initialize Email Selection\", key=\"init_email_selection\"):\n                    # Initialize selection with businesses that have emails\n                    st.session_state.selected_for_email = [\n                        pd.notna(row['email']) and \n                        row['email'] not in ['', 'Not found', 'Research required'] and\n                        'not relevant' not in str(row['email']).lower()\n                        for _, row in results_df.iterrows()\n                    ]\n                    st.rerun()\n        \n        display_results_summary(results_df)\n        \n        # Add selection indicators to the dataframe display\n        if 'selected_for_email' in st.session_state and len(st.session_state.selected_for_email) == len(results_df):\n            # Add selection column for display\n            display_df = results_df.copy()\n            display_df.insert(0, 'üìß Selected', ['‚òëÔ∏è Yes' if selected else '‚òê No' for selected in st.session_state.selected_for_email])\n            st.dataframe(display_df, use_container_width=True, height=400)\n        else:\n            st.dataframe(results_df, use_container_width=True, height=400)\n        \n        # Download options in view mode\n        col_download1, col_download2 = st.columns(2)\n        \n        with col_download1:\n            # Download all results\n            csv_data = results_df.to_csv(index=False)\n            st.download_button(\n                label=\"üìÑ Download All Results\",\n                data=csv_data,\n                file_name=f\"research_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                mime=\"text/csv\"\n            )\n        \n        with col_download2:\n            # Download only selected businesses\n            if 'selected_for_email' in st.session_state and any(st.session_state.selected_for_email):\n                selected_results = results_df[st.session_state.selected_for_email]\n                selected_csv = selected_results.to_csv(index=False)\n                st.download_button(\n                    label=f\"üìß Download Selected ({sum(st.session_state.selected_for_email)})\",\n                    data=selected_csv,\n                    file_name=f\"selected_businesses_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\"\n                )\n            else:\n                st.button(\"üìß Download Selected (0)\", disabled=True, help=\"No businesses selected\")\n\ndef create_editable_business_data(df):\n    \"\"\"Create editable interface for business data using Streamlit data editor\"\"\"\n    \n    # Add email selection column to dataframe\n    df_with_selection = df.copy()\n    df_with_selection.insert(0, 'send_email', st.session_state.selected_for_email)\n    \n    # Initialize the data editor state if it doesn't exist\n    editor_key = \"business_data_editor\"\n    if editor_key not in st.session_state:\n        st.session_state[editor_key] = df_with_selection.copy()\n    \n    # Key editable columns\n    editable_columns = [\n        'send_email', 'business_name', 'email', 'phone', 'website', 'address', \n        'city', 'description', 'registration_number'\n    ]\n    \n    # Configure column settings for better editing experience\n    column_config = {\n        'send_email': st.column_config.CheckboxColumn(\n            \"üìß Send Email\",\n            help=\"Select businesses to include in email campaign\",\n            default=False,\n        ),\n        'business_name': st.column_config.TextColumn(\n            \"Business Name\",\n            help=\"Name of the business\",\n            max_chars=100,\n        ),\n        'email': st.column_config.TextColumn(\n            \"Email Address\", \n            help=\"Email address for business contact\",\n            validate=\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        ),\n        'phone': st.column_config.TextColumn(\n            \"Phone Number\",\n            help=\"Phone number for business contact\",\n            max_chars=50,\n        ),\n        'website': st.column_config.LinkColumn(\n            \"Website\",\n            help=\"Business website URL\",\n            validate=\"^https?://.*\",\n        ),\n        'address': st.column_config.TextColumn(\n            \"Address\",\n            help=\"Business address\",\n            max_chars=200,\n        ),\n        'city': st.column_config.TextColumn(\n            \"City\",\n            help=\"Business city/location\",\n            max_chars=50,\n        ),\n        'description': st.column_config.TextColumn(\n            \"Description\",\n            help=\"Business description and activities\",\n            max_chars=300,\n        ),\n        'registration_number': st.column_config.TextColumn(\n            \"Registration #\",\n            help=\"Business registration or GST number\",\n            max_chars=50,\n        ),\n        'confidence': st.column_config.NumberColumn(\n            \"Confidence\",\n            help=\"Research confidence score (1-10)\",\n            min_value=1,\n            max_value=10,\n            step=1,\n            format=\"%d\"\n        ),\n        'government_verified': st.column_config.SelectboxColumn(\n            \"Gov Verified\",\n            help=\"Whether verified through government sources\",\n            options=['YES', 'NO']\n        ),\n        'industry_relevant': st.column_config.SelectboxColumn(\n            \"Industry Relevant\", \n            help=\"Whether business is relevant to timber/wood industry\",\n            options=['YES', 'NO', 'UNKNOWN']\n        ),\n        'location_relevant': st.column_config.SelectboxColumn(\n            \"Location Relevant\",\n            help=\"Whether business location matches expected location\", \n            options=['YES', 'NO', 'UNKNOWN']\n        )\n    }\n    \n    # Show editing instructions\n    st.markdown(\"üîß **Quick Edit Tips:**\")\n    tips_col1, tips_col2 = st.columns(2)\n    \n    with tips_col1:\n        st.markdown(\"\"\"\n        **üìß Email:** Enter valid email addresses  \n        **üìû Phone:** Use any format (e.g., +91-9876543210)  \n        **üåê Website:** Include https:// prefix\n        \"\"\")\n    \n    with tips_col2:\n        st.markdown(\"\"\"\n        **üìç Address:** Full business address  \n        **üè¢ Registration:** GST or company registration number  \n        **üìù Description:** Brief business description\n        \"\"\")\n    \n    # Create the editable data editor with proper state handling\n    try:\n        edited_df_with_selection = st.data_editor(\n            df_with_selection,\n            column_config=column_config,\n            use_container_width=True,\n            num_rows=\"dynamic\",  # Allow adding/removing rows\n            height=500,\n            key=editor_key\n        )\n        \n        # Store the current editor state for future reference\n        st.session_state[f\"{editor_key}_current\"] = edited_df_with_selection.copy()\n        \n    except Exception as e:\n        st.error(f\"Error with data editor: {str(e)}\")\n        # Fallback to session state data\n        edited_df_with_selection = st.session_state.get(f\"{editor_key}_current\", df_with_selection)\n    \n    # Update email selection state from the editor\n    if 'send_email' in edited_df_with_selection.columns:\n        try:\n            st.session_state.selected_for_email = edited_df_with_selection['send_email'].tolist()\n        except Exception as e:\n            st.warning(f\"Could not update email selection: {str(e)}\")\n    \n    # Remove the send_email column before returning the business data\n    edited_df = edited_df_with_selection.drop(columns=['send_email'], errors='ignore')\n    \n    return edited_df\n\ndef display_results_summary(df):\n    \"\"\"Display summary statistics for results\"\"\"\n    \n    total_businesses = len(df)\n    businesses_with_emails = len(df[df['email'].notna() & (df['email'] != '') & (df['email'] != 'Not found')])\n    businesses_with_phones = len(df[df['phone'].notna() & (df['phone'] != '') & (df['phone'] != 'Not found')])\n    businesses_with_websites = len(df[df['website'].notna() & (df['website'] != '') & (df['website'] != 'Not found')])\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Total Businesses\", total_businesses)\n    with col2:\n        st.metric(\"üìß With Emails\", businesses_with_emails)  \n    with col3:\n        st.metric(\"üìû With Phones\", businesses_with_phones)\n    with col4:\n        st.metric(\"üåê With Websites\", businesses_with_websites)\n\ndef show_changes_summary(original_df, edited_df):\n    \"\"\"Show summary of changes made to the data\"\"\"\n    \n    changes_count = 0\n    \n    try:\n        # Compare dataframes and count changes\n        if original_df.shape != edited_df.shape:\n            changes_count += abs(original_df.shape[0] - edited_df.shape[0])\n            st.info(f\"üìä Row count changed: {original_df.shape[0]} ‚Üí {edited_df.shape[0]}\")\n        \n        # Check for cell-level changes in common rows\n        common_rows = min(len(original_df), len(edited_df))\n        \n        for idx in range(common_rows):\n            for col in original_df.columns:\n                if col in edited_df.columns:\n                    orig_val = str(original_df.iloc[idx][col]) if pd.notna(original_df.iloc[idx][col]) else \"\"\n                    edit_val = str(edited_df.iloc[idx][col]) if pd.notna(edited_df.iloc[idx][col]) else \"\"\n                    \n                    if orig_val != edit_val:\n                        changes_count += 1\n                        \n                        # Show specific change details for key fields\n                        if col in ['email', 'phone', 'website'] and changes_count <= 5:\n                            business_name = edited_df.iloc[idx].get('business_name', f'Row {idx+1}')\n                            st.write(f\"üìù **{business_name}** - {col}: `{orig_val}` ‚Üí `{edit_val}`\")\n        \n        if changes_count > 5:\n            st.write(f\"... and {changes_count - 5} more changes\")\n            \n    except Exception as e:\n        st.warning(f\"Could not compare changes: {str(e)}\")\n        changes_count = 1  # Assume changes were made\n    \n    return changes_count\n\ndef update_researcher_results(researcher, edited_df):\n    \"\"\"Update the researcher instance with edited results\"\"\"\n    \n    try:\n        # Convert edited dataframe back to researcher's internal format\n        updated_results = []\n        \n        for idx, row in edited_df.iterrows():\n            # Create a result entry in the researcher's format\n            result_entry = {\n                'business_name': row.get('business_name', ''),\n                'status': 'success' if row.get('email', '') not in ['', 'Not found', 'Research required'] else 'manual_required',\n                'government_sources_found': 1 if row.get('government_verified', 'NO') == 'YES' else 0,\n                'industry_sources_found': 0,\n                'total_sources': 1,\n                'research_date': datetime.now().isoformat(),\n                'method': 'Manual Edit',\n                'extracted_info': create_extracted_info_from_row(row)\n            }\n            updated_results.append(result_entry)\n        \n        # Update the researcher's results\n        researcher.results = updated_results\n        \n    except Exception as e:\n        st.warning(f\"Could not update researcher results: {str(e)}\")\n\ndef create_extracted_info_from_row(row):\n    \"\"\"Create extracted info string from dataframe row for researcher compatibility\"\"\"\n    \n    return f\"\"\"\nBUSINESS_NAME: {row.get('business_name', '')}\nINDUSTRY_RELEVANT: {row.get('industry_relevant', 'YES')}\nLOCATION_RELEVANT: {row.get('location_relevant', 'YES')}\nPHONE: {row.get('phone', 'Not found')}\nEMAIL: {row.get('email', 'Not found')}\nWEBSITE: {row.get('website', 'Not found')}\nADDRESS: {row.get('address', 'Not found')}\nCITY: {row.get('city', 'Not found')}\nREGISTRATION_NUMBER: {row.get('registration_number', 'Not found')}\nLICENSE_DETAILS: {row.get('license_details', 'Not found')}\nDIRECTORS: {row.get('directors', 'Not found')}\nDESCRIPTION: {row.get('description', 'Business activities')}\nGOVERNMENT_VERIFIED: {row.get('government_verified', 'NO')}\nCONFIDENCE: {row.get('confidence', '5')}\nRELEVANCE_NOTES: Manual edit - {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\"\"\"\n\ndef perform_web_scraping(filtered_df):\n    \"\"\"Enhanced web scraping with real-time progress updates and email integration\"\"\"\n    \n    # Check if DataFrame is empty\n    if len(filtered_df) == 0:\n        st.error(\"‚ùå No data to scrape. Please adjust your filters.\")\n        return\n\n    # Find suitable columns for business names\n    potential_name_columns = []\n    for col in filtered_df.columns:\n        col_lower = col.lower()\n        if any(keyword in col_lower for keyword in ['consignee', 'name', 'company', 'business', 'shipper', 'supplier']):\n            potential_name_columns.append(col)\n\n    if not potential_name_columns:\n        st.error(\"‚ùå No suitable business name columns found. Need columns like 'Consignee Name', 'Company Name', etc.\")\n        return\n\n    # User selects which column to use for business names\n    st.write(\"üè∑Ô∏è **Select Business Name Column:**\")\n    selected_column = st.selectbox(\n        \"Choose the column containing business names:\",\n        potential_name_columns,\n        help=\"Select the column that contains the business names you want to research\",\n        key=\"business_name_column_selector\"\n    )\n\n    # Check unique business count\n    unique_businesses = filtered_df[selected_column].dropna().nunique()\n    if unique_businesses == 0:\n        st.error(f\"‚ùå No business names found in column '{selected_column}'\")\n        return\n\n    st.info(f\"üìä Found {unique_businesses} unique businesses to research in '{selected_column}'\")\n\n    # Research limit selection\n    if 'business_range_from' not in st.session_state:\n        st.session_state.business_range_from = 1\n    if 'business_range_to' not in st.session_state:\n        st.session_state.business_range_to = min(3, unique_businesses)  # Reduced default for testing\n\n    st.write(\"üéØ **Business Research Range:**\")\n    col_from, col_to = st.columns(2)\n    \n    with col_from:\n        range_from = st.number_input(\n            \"From:\",\n            min_value=1,\n            max_value=min(10, unique_businesses),  # Reduced max for testing\n            value=st.session_state.business_range_from,\n            help=\"Starting business number\",\n            key=\"business_range_from_input\"\n        )\n    \n    with col_to:\n        range_to = st.number_input(\n            \"To:\",\n            min_value=range_from,\n            max_value=min(10, unique_businesses),  # Reduced max for testing\n            value=max(st.session_state.business_range_to, range_from),\n            help=\"Ending business number\",\n            key=\"business_range_to_input\"\n        )\n    \n    # Calculate number of businesses to research\n    max_businesses = range_to - range_from + 1\n    \n    # Update session state\n    st.session_state.business_range_from = range_from\n    st.session_state.business_range_to = range_to\n    \n    # Show summary\n    st.info(f\"üìä Will research businesses {range_from} to {range_to} ({max_businesses} total businesses)\")\n\n    # Cost estimation\n    estimated_cost = max_businesses * 0.03\n    st.warning(f\"üí∞ **Estimated API Cost:** ~${estimated_cost:.2f} (approx $0.03 per business)\")\n\n    # API Configuration check\n    st.write(\"üîß **API Configuration:**\")\n\n    # Get API keys using Railway-compatible method\n    groq_key = get_env_var('GROQ_API_KEY')\n    tavily_key = get_env_var('TAVILY_API_KEY')\n\n    # Key validation - More flexible for Railway\n    def is_valid_key(key, key_type):\n        if not key or key.strip() == '':\n            return False, \"Key is empty or missing\"\n        if key.strip() in ['your_groq_key_here', 'your_tavily_key_here']:\n            return False, \"Key is a placeholder value\"\n        if len(key.strip()) < 10:\n            return False, \"Key appears too short\"\n        if len(key) > 15:\n            return True, \"Key format appears valid\"\n        return False, \"Key format validation failed\"\n\n    groq_valid, groq_reason = is_valid_key(groq_key, 'groq')\n    tavily_valid, tavily_reason = is_valid_key(tavily_key, 'tavily')\n\n    # Display status\n    col_api1, col_api2 = st.columns(2)\n\n    with col_api1:\n        if groq_valid:\n            st.success(\"‚úÖ Groq API Key: Configured\")\n        else:\n            st.error(f\"‚ùå Groq API Key: {groq_reason}\")\n\n    with col_api2:\n        if tavily_valid:\n            st.success(\"‚úÖ Tavily API Key: Configured\")\n        else:\n            st.error(f\"‚ùå Tavily API Key: {tavily_reason}\")\n\n    # Show setup instructions if keys are invalid\n    if not groq_valid or not tavily_valid:\n        st.warning(\"‚ö†Ô∏è **Setup Required**: Please configure both API keys in Railway environment variables.\")\n        return\n\n    # Start research button\n    both_apis_configured = groq_valid and tavily_valid\n    st.markdown(\"---\")\n\n    if st.button(\n        f\"üöÄ Start Enhanced Research ({max_businesses} businesses)\",\n        type=\"primary\",\n        disabled=not both_apis_configured,\n        key=\"start_research_button\"\n    ):\n\n        st.markdown(\"---\")\n        st.subheader(\"üîç **Live Research Progress**\")\n        \n        # Initialize progress tracker\n        progress_tracker = ProgressTracker(max_businesses)\n        progress_tracker.update_stage(\"initializing\", \"Setting up research environment...\")\n\n        try:\n            # Import check with detailed feedback\n            progress_tracker.update_details(\"üì¶ Loading research modules...\")\n            \n            try:\n                from modules.streamlit_business_researcher import StreamlitBusinessResearcher\n                progress_tracker.update_details(\"‚úÖ StreamlitBusinessResearcher loaded\")\n            except ImportError as e:\n                progress_tracker.update_details(f\"‚ùå Import failed: {e}\")\n                st.error(f\"Module import error: {e}\")\n                return\n\n            # API Test\n            progress_tracker.update_stage(\"api_test\", \"Testing API connections...\")\n            \n            researcher = StreamlitBusinessResearcher()\n            api_ok, api_message = researcher.test_apis()\n            \n            if not api_ok:\n                progress_tracker.update_stage(\"failed\", f\"API test failed: {api_message}\")\n                st.error(f\"API test failed: {api_message}\")\n                return\n            \n            progress_tracker.update_details(\"‚úÖ API connections verified\")\n\n            # Prepare business data\n            progress_tracker.update_stage(\"preparing\", \"Preparing business data...\")\n            \n            unique_businesses_list = filtered_df[selected_column].dropna().unique()\n            start_idx = range_from - 1\n            end_idx = range_to\n            businesses_to_research = unique_businesses_list[start_idx:end_idx]\n            research_df = filtered_df[filtered_df[selected_column].isin(businesses_to_research)]\n\n            progress_tracker.update_details(f\"üìã Prepared {len(businesses_to_research)} businesses\")\n\n            # Auto-detect location columns\n            city_column = None\n            address_column = None\n            \n            for col in research_df.columns:\n                if 'city' in col.lower() and not city_column:\n                    city_column = col\n                if 'address' in col.lower() and not address_column:\n                    address_column = col\n            \n            progress_tracker.update_details(f\"üìç Location columns detected: City='{city_column}', Address='{address_column}'\")\n\n            # Prepare business list with location info\n            business_data = []\n            for _, row in research_df.iterrows():\n                business_name = row.get(selected_column)\n                if pd.notna(business_name) and str(business_name).strip():\n                    city = row.get(city_column) if city_column else None\n                    address = row.get(address_column) if address_column else None\n                    business_data.append({\n                        'name': str(business_name).strip(),\n                        'city': str(city).strip() if pd.notna(city) else None,\n                        'address': str(address).strip() if pd.notna(address) else None\n                    })\n\n            # Remove duplicates\n            unique_businesses = {}\n            for item in business_data:\n                if item['name'] not in unique_businesses:\n                    unique_businesses[item['name']] = item\n            \n            business_list = list(unique_businesses.values())\n            \n            progress_tracker.update_details(f\"üéØ Starting research for {len(business_list)} unique businesses\")\n\n            # Research each business with timeout and error handling\n            def research_single_business(business_info, business_num):\n                \"\"\"Research a single business with timeout\"\"\"\n                business_name = business_info['name']\n                expected_city = business_info['city']\n                expected_address = business_info['address']\n                \n                try:\n                    # Update progress\n                    progress_tracker.update_business(business_num, business_name)\n                    \n                    if expected_city:\n                        progress_tracker.update_details(f\"üìç Expected City: {expected_city}\")\n                    \n                    # Simulate research stages with timeouts\n                    stages = [\n                        (\"general_search\", \"Searching general business info...\"),\n                        (\"government_search\", \"Searching government databases...\"),\n                        (\"industry_search\", \"Searching timber industry sources...\"),\n                        (\"extracting\", \"Analyzing results with AI...\"),\n                        (\"verifying\", \"Verifying business relevance...\")\n                    ]\n                    \n                    for stage, description in stages:\n                        progress_tracker.update_stage(stage, description)\n                        time.sleep(1)  # Simulate work\n                        \n                        # Check for timeout\n                        if time.time() - progress_tracker.start_time > 300:  # 5 minute timeout\n                            raise TimeoutError(\"Research timeout exceeded\")\n                    \n                    # Simulate actual research call with timeout\n                    def run_actual_research():\n                        loop = asyncio.new_event_loop()\n                        asyncio.set_event_loop(loop)\n                        try:\n                            result = loop.run_until_complete(\n                                asyncio.wait_for(\n                                    researcher.research_business_direct(business_name, expected_city, expected_address),\n                                    timeout=60.0  # 1 minute per business\n                                )\n                            )\n                            return result\n                        except asyncio.TimeoutError:\n                            return {\n                                'status': 'manual_required',\n                                'business_name': business_name,\n                                'government_sources_found': 0,\n                                'extracted_info': f'Research timeout for {business_name}'\n                            }\n                        finally:\n                            loop.close()\n                    \n                    # Run research with thread timeout\n                    with concurrent.futures.ThreadPoolExecutor() as executor:\n                        future = executor.submit(run_actual_research)\n                        try:\n                            result = future.result(timeout=90)  # 1.5 minute total timeout\n                        except concurrent.futures.TimeoutError:\n                            progress_tracker.update_stage(\"timeout\", f\"Timeout researching {business_name}\")\n                            result = {\n                                'status': 'manual_required',\n                                'business_name': business_name,\n                                'government_sources_found': 0\n                            }\n                    \n                    # Update results\n                    govt_sources = result.get('government_sources_found', 0)\n                    progress_tracker.add_result(result['status'], govt_sources)\n                    \n                    if result['status'] == 'success':\n                        progress_tracker.update_stage(\"completed\", f\"‚úÖ Successfully researched {business_name}\")\n                    else:\n                        progress_tracker.update_stage(\"completed\", f\"‚ö†Ô∏è Manual research required for {business_name}\")\n                    \n                    return result\n                    \n                except Exception as e:\n                    progress_tracker.update_stage(\"failed\", f\"Error: {str(e)[:50]}\")\n                    progress_tracker.add_result(\"manual_required\")\n                    return {\n                        'status': 'manual_required',\n                        'business_name': business_name,\n                        'government_sources_found': 0,\n                        'error': str(e)\n                    }\n\n            # Process each business\n            for i, business_info in enumerate(business_list, 1):\n                research_single_business(business_info, i)\n                \n                # Short delay between businesses\n                time.sleep(2)\n\n            # Complete research\n            progress_tracker.complete()\n\n            # Get final results\n            results_df = researcher.get_results_dataframe()\n            \n            if results_df is not None and not results_df.empty:\n                st.markdown(\"---\")\n                st.subheader(\"üéâ **Final Results**\")\n                \n                # Enhanced summary\n                summary = {\n                    'total_processed': len(researcher.results),\n                    'successful': progress_tracker.successful,\n                    'government_verified': progress_tracker.government_verified,\n                    'manual_required': progress_tracker.manual_required,\n                    'success_rate': progress_tracker.successful/len(researcher.results)*100 if researcher.results else 0\n                }\n                \n                col_sum1, col_sum2, col_sum3, col_sum4 = st.columns(4)\n                with col_sum1:\n                    st.metric(\"Total Processed\", summary['total_processed'])\n                with col_sum2:\n                    st.metric(\"Successful\", summary['successful'])\n                with col_sum3:\n                    st.metric(\"Manual Required\", summary['manual_required'])\n                with col_sum4:\n                    st.metric(\"Success Rate\", f\"{summary['success_rate']:.1f}%\")\n\n                # Store research results and researcher instance in session state for email functionality\n                st.session_state.research_completed = True\n                st.session_state.researcher_instance = researcher\n                st.session_state.research_results = results_df\n                st.session_state.research_summary = summary\n                st.session_state.results_edit_mode = False  # Start in view mode\n\n                st.balloons()\n                \n                # Show success message with email information\n                businesses_with_emails = researcher.get_businesses_with_emails()\n                if len(businesses_with_emails) > 0:\n                    st.success(f\"üéâ Research completed! Found email addresses for {len(businesses_with_emails)} businesses. You can now edit the results and send emails.\")\n                else:\n                    st.info(\"‚ÑπÔ∏è Research completed! No email addresses were found in the results. You can manually add them using the edit feature below.\")\n                \n            else:\n                st.warning(\"‚ö†Ô∏è Research completed but no results were found.\")\n\n        except Exception as e:\n            progress_tracker.update_stage(\"failed\", f\"System error: {str(e)}\")\n            st.error(f\"‚ùå System Error: {str(e)}\")\n            \n            with st.expander(\"üîç Technical Details\"):\n                st.code(str(e))\n    \n    # Show editable results interface if research is completed\n    create_editable_results_interface()\n